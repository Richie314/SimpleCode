using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections;
using System.Web;
using System.Threading;

namespace TictacToeHelper
{
    public class TicTacToe
    {
        public enum Entity
        {
            X,
            O,
            B,
            Error,
            xToP,
            oToP
        }
        public class Configuration
        {
            public enum Types
            {
                ForX,
                ForO, 
                Error
            }
            public Types Type { get; set; }
            public Entity[][] Board { get; set; }
            public Configuration(
                Configuration c)
            {
                Board = c.Board;
                Type = c.Type;
            }
            public Configuration(
                Entity[] row0, Entity[] row1, Entity[] row2)
            {
                Type = Types.Error;
                Board = new Entity[][]
                {
                    row0,
                    row1,
                    row2
                };
                foreach (Entity[] row in Board)
                {
                    if (row.Contains(Entity.xToP))
                    {
                        Type = Types.ForX;
                    }
                    else if (row.Contains(Entity.oToP))
                    {
                        Type = Types.ForO;
                    }
                }
            }
            public Configuration(
                Entity a0, Entity b0, Entity c0,
                Entity a1, Entity b1, Entity c1,
                Entity a2, Entity b2, Entity c2):this(
                    new Entity[] { a0, b0, c0 },
                    new Entity[] { a1, b1, c1 },
                    new Entity[] { a2, b2, c2 })
            {  }
            public Configuration(
                string s) : this(
                    s.Substring(0, 3).Select(GetFromChar).ToArray(),
                    s.Substring(3, 3).Select(GetFromChar).ToArray(),
                    s.Substring(6, 3).Select(GetFromChar).ToArray())
            {  }
            public Configuration(
                string a, string b, string c) : this(
                    a.Select(GetFromChar).ToArray(),
                    b.Select(GetFromChar).ToArray(),
                    c.Select(GetFromChar).ToArray())
            { }
            public Configuration sY()
            {
                return new Configuration(Board[2], Board[1], Board[0]);
            }
            public Entity[] Col(int index)
            {
                if (index < 0 || index > 2)
                    return new Entity[] { };
                return new Entity[] {
                    Board[0][index],
                    Board[1][index],
                    Board[2][index] };
            }
            public static Configuration FromColumns(
                Entity[] a, Entity[] b, Entity[] c)
            {
                return new Configuration(
                    a[0], b[0], c[0],
                    a[1], b[1], c[1],
                    a[2], b[2], c[2]);
            }
            public Configuration sX()
            {
                return FromColumns(Col(2), Col(1), Col(0));
            }
            private static void Swap2(
                ref Entity a, ref Entity b)
            {
                Entity e = a;
                a = b;
                b = e;
            }
            private static void Swap4(
                ref Entity a, ref Entity b, ref Entity c, ref Entity d)
            {
                Entity e = d;
                d = c;
                c = b;
                b = a;
                a = e;
            }
            public Configuration r90(int times = 1)
            {
                Configuration c = new Configuration(this);
                for (int i = 0; i < times; i++)
                {
                    Configuration.Swap4(
                        ref c.Board[0][0],
                        ref c.Board[0][2],
                        ref c.Board[2][2],
                        ref c.Board[2][0]);
                    Configuration.Swap4(
                        ref c.Board[0][1],
                        ref c.Board[1][2],
                        ref c.Board[2][1],
                        ref c.Board[1][0]);
                }
                return c;
            }
            /// <summary>
            /// Symmetry over y=x line
            /// </summary>
            public Configuration s13()
            {
                Configuration c = new Configuration(this);
                Configuration.Swap2(
                        ref c.Board[0][0],
                        ref c.Board[2][2]);
                Configuration.Swap2(
                        ref c.Board[0][1],
                        ref c.Board[1][2]);
                Configuration.Swap2(
                        ref c.Board[1][0],
                        ref c.Board[2][1]);
                return c;
            }
            /// <summary>
            /// Symmetry over y=-x line
            /// </summary>
            public Configuration s24()
            {
                Configuration c = new Configuration(this);
                Configuration.Swap2(
                        ref c.Board[0][2],
                        ref c.Board[2][0]);
                Configuration.Swap2(
                        ref c.Board[0][1],
                        ref c.Board[1][0]);
                Configuration.Swap2(
                        ref c.Board[1][2],
                        ref c.Board[2][1]);
                return c;
            }
            public bool Is(Entity[][] B)
            {
                for (int i = 0; i < 3; i++)
                {
                    for (int j = 0; j < 3; j++)
                    {
                        if (Board[i][j] != B[i][j] && 
                            Board[i][j] != Entity.xToP &&
                            Board[i][j] != Entity.oToP)
                        {
                            return false;
                        }
                    }
                }
                return true;
            }
        }
        private static Configuration[] Strategy =
        {
            //For X
            new Configuration(
                "   ",
                " x ",
                "   "),
            new Configuration(
                "x  ",
                "OX ",
                "   "),
            new Configuration(
                "O  ",
                " X ",
                "  x"),
            new Configuration(
                "O x",
                " X ",
                " OX"),
            //For O
            new Configuration(
                "o  ",
                " X ",
                "   "),
            new Configuration(
                "X  ",
                " o ",
                "   "),
            new Configuration(
                "O  ",
                " X ",
                "o X"),
            new Configuration(
                "Xo ",
                " O ",
                "  X"),
            new Configuration(
                " Xo",
                " O ",
                " X "),
            new Configuration(
                "  o",
                " OX",
                " X "),
            new Configuration(
                " Xo",
                " O ",
                " X "),
            new Configuration(
                "O  ",
                "XXO",
                "o X"),
            new Configuration(
                "O X",
                "XXO",
                "OoX"),
            new Configuration(
                "X  ",
                "OOX",
                "Xo "),
            new Configuration(
                "o X",
                "XO ",
                "   "),
            new Configuration(
                "OXX",
                "XOO",
                "o X")
        };
        private static Entity GetFromChar(char c)
        {
            switch (c)
            {
                case 'X':
                    return Entity.X;
                case 'O':
                    return Entity.O;
                case 'x':
                    return Entity.xToP;
                case 'o':
                    return Entity.oToP;
                case ' ':
                case 'B':
                default:
                    return Entity.B;
            }
        }
        public static string PrintEntity(Entity E)
        {
            switch (E)
            {
                case Entity.X:
                    return "X";
                case Entity.O:
                    return "O";
                case Entity.Error:
                    return "Error";
                case Entity.xToP:
                    return "xHere";
                case Entity.oToP:
                    return "oHere";
                case Entity.B:
                default:
                    return " ";
            }
        }
        public Entity[] Col(int index)
        {
            if (index < 0 || index > 2)
                return new Entity[] { };
            return new Entity[] {
                    Board[0][index],
                    Board[1][index],
                    Board[2][index] };
        }
        private Entity GetActivePlayer()
        {
            return GetTurn() % 2 == 0 ? Entity.O : Entity.X;
        }
        private Entity GetPreviousPlayer()
        {
            int _Turn = GetTurn();
            if (_Turn == 1)
                return Entity.Error;
            return _Turn % 2 == 0 ? Entity.X : Entity.O;
        }
        /// <summary>
        /// Doesn't check if is finished
        /// </summary>
        /// <returns>The player that is about to make his move</returns>
        public Entity ActivePlayer { get => GetActivePlayer(); }
        /// <summary>
        /// Doesn't check if is finished
        /// </summary>
        /// <returns>The last player that is made a move, Error if is first turn</returns>
        public Entity PreviousPlayer { get => GetPreviousPlayer(); }
        public Entity[][] Board { get; set; }
        public TicTacToe()
        {
            Board = new Entity[][]
            {
                new Entity[] { Entity.B, Entity.B, Entity.B },
                new Entity[] { Entity.B, Entity.B, Entity.B },
                new Entity[] { Entity.B, Entity.B, Entity.B }
            };
        }
        public TicTacToe(string board):this()
        {
            Parse(board);
        }
        private void Parse(string str)
        {
            if (str.Length != 9)
            {
                return;
            }
            Board = new Entity[][] {
                str.Substring(0, 3).Select(GetFromChar).ToArray(),
                str.Substring(3, 3).Select(GetFromChar).ToArray(),
                str.Substring(6, 3).Select(GetFromChar).ToArray()
            };
        }
        private int Count(Entity e)
        {
            int c = 0;
            foreach (Entity[] Row in Board)
            {
                c += Row.OccurencesOf(e);
            }
            return c;
        }
        private bool IsFinished()
        {
            if (!IsValid())
            {
                return true;//Error
            }
            return 
                HasWon(Entity.X) || 
                HasWon(Entity.O) || 
                Count(Entity.X) + Count(Entity.O) + Count(Entity.B) == 9;//Draw
        }
        private bool IsDraw()
        {
            if (!IsValid())
                return false;
            return 
                (!HasWon(Entity.X)) &&
                (!HasWon(Entity.O)) &&
                Count(Entity.X) + Count(Entity.O) + Count(Entity.B) == 9;//Draw
        }
        private int GetTurn()
        {
            return 10 - Count(Entity.B);//9 - cellevuote + 1
        }
        public bool Finished { get => IsFinished(); }
        public bool Valid { get => IsValid(); }
        public bool Draw { get => IsDraw(); }
        /// <summary>
        /// Il turno attivo, da 1 a 9
        /// 1,3,5,7,9 per X
        /// 2,4,6,8 per O
        /// </summary>
        /// <returns>Il turno attivo, da 1 a 9</returns>
        public int Turn { get => GetTurn(); }
        private static bool Are3(Entity[] stripe, Entity e)
        {
            if (stripe.Length != 3)
                return false;
            return stripe.All(cell => cell == e);
        }
        private static bool Are2AndBlank(Entity[] stripe, Entity e)
        {
            if (stripe.Length != 3 || stripe.OccurencesOf(Entity.B) != 1)
                return false;
            return stripe.OccurencesOf(e) == 2;
        }
        private Entity[] Line13()
        {
            return new Entity[]
            {
                Board[0][0],
                Board[1][1],
                Board[2][2]
            };
        }
        private Entity[] Line24()
        {
            return new Entity[]
            {
                Board[2][0],
                Board[1][1],
                Board[0][2]
            };
        }
        /// <summary>
        /// Does not check for board validation
        /// </summary>
        /// <param name="E">X or O</param>
        public bool HasWon(Entity E)
        {
            for (int i = 0; i < 3; i++)
                if (Are3(Col(i), E))
                    return true;
            for (int i = 0; i < 3; i++)
                if (Are3(Board[i], E))
                    return true;
            if (Are3(Line13(), E))
                return true;
            return Are3(Line24(), E);
        }
        private bool IsValid()
        {
            if (
                Count(Entity.Error) > 0 || 
                Count(Entity.xToP) > 0 || 
                Count(Entity.oToP) > 0)
            {
                return false;
            }
            int xCount = Count(Entity.X);
            int oCount = Count(Entity.O);

            int diff = xCount - oCount;
            if (diff != 0 && diff != 1)
                return false;
            if (xCount + oCount + Count(Entity.B) != 9)
                return false;
            return !(HasWon(Entity.X) && HasWon(Entity.O));//Can't have two winners
        }

        public string [][] AsString()
        {
            return Board.Select(
                Row => Row.Select(
                    Cell => PrintEntity(Cell)
                    ).ToArray()).ToArray();
        }
        public class Move
        {
            private int row, col;
            private Entity val;
            public Move()
            {
                row = 0;
                col = 0;
                val = Entity.B;
            }
            public Move(int _Row, int _Col, Entity E):this()
            {
                UpdateRow(_Row);
                UpdateColumn(_Col);
                UpdatePlayer(E);
            }
            private void UpdateRow(int r)
            {
                if (r < 0 || r > 2)
                    return;
                row = r;
            }
            public int Row
            {
                get => row;
                set => UpdateRow(value);
            }
            public int Y
            {
                get => row;
                set => UpdateRow(value);
            }
            private void UpdateColumn(int c)
            {
                if (c < 0 || c > 2)
                    return;
                col = c;
            }
            public int Column
            {
                get => col;
                set => UpdateColumn(value);
            }
            public int X
            {
                get => col;
                set => UpdateColumn(value);
            }
            private void UpdatePlayer(Entity E)
            {
                if (E != Entity.X && E != Entity.O)
                    return;
                val = E;
            }
            public Entity Player
            {
                get => val;
                set => UpdatePlayer(value);
            }
        }
        /// <summary>
        /// Doesn't check if game is valid or ended
        /// </summary>
        public Move GetBestMove()
        {
            Entity P = GetActivePlayer();
            //Check rows for complete
            for (int i = 0; i < 3; i++)
            {
                if (Are2AndBlank(Board[i], P))
                {
                    return new Move(i, Board[i].IndexOf(Entity.B), P);
                }
            }
            //Check cols for complete
            for (int i = 0; i < 3; i++)
            {
                if (Are2AndBlank(Col(i), P))
                {
                    return new Move(Board[i].IndexOf(Entity.B), i, P);
                }
            }
            //Check for line 13 and 24
            Entity[] Line = Line13();
            if (Are2AndBlank(Line, P))
            {
                //pattern: 0,0 1,1 2,2 -> i,i
                int i = Line.IndexOf(Entity.B);
                return new Move(i, i, P);
            }
            Line = Line24();
            if (Are2AndBlank(Line, P))
            {
                //pattern: 2,0 1,1 0,2 -> 2-i,i
                int i = Line.IndexOf(Entity.B);
                return new Move(2 - i, i, P);
            }
            //If we get here it means we have not two cells already aligned
            return CheckForStrategies(P);
        }
        private Move GetFromConfig(Configuration c)
        {
            if (c.Type == Configuration.Types.Error)
                return new Move(0, 0, Entity.Error);
            Entity toSearch = c.Type == Configuration.Types.ForX ? Entity.X : Entity.O;
            for (int i = 0; i < 3; i++)
            {
                int j = c.Board[i].IndexOf(toSearch);
                if (j >= 0)
                {
                    return new Move(i, j, toSearch);
                }
            }
            return new Move(0, 0, Entity.Error);
        }
        private Move CheckForStrategies(Entity P)
        {
            foreach (Configuration Config in Strategy.Where(
                c => (c.Type == Configuration.Types.ForX && P == Entity.X) ||
                    (c.Type == Configuration.Types.ForO && P == Entity.O)))
            {
                //Check for instant match
                if (Config.Is(Board))
                    return GetFromConfig(Config);
                //Check permutations
                Configuration Test = Config.sX();
                if (Test.Is(Board))
                    return GetFromConfig(Test);
                Test = Config.sY();
                if (Test.Is(Board))
                    return GetFromConfig(Test);
                Test = Config.s13();
                if (Test.Is(Board))
                    return GetFromConfig(Test);
                Test = Config.s24();
                if (Test.Is(Board))
                    return GetFromConfig(Test);
                for (int i = 1; i < 4; i++)
                {
                    Test = Test.r90();
                    if (Test.Is(Board))
                        return GetFromConfig(Test);
                }
            }

            //The database isn't complete!
            
            
            
            //INSERT YOUR CODE HERE TO THROW ERROR
            
            
            //Check for blank cell
            for (int i = 0; i < 3; i++)
            {
                int j = Board[i].IndexOf(Entity.B);
                if (j >= 0)
                    return new Move(i, j, P);
            }
            return new Move(0, 0, P);//Error, have to return something
        }
        public void Play(Move move)
        {

        }
    }

}
